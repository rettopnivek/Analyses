# trailing/leading zeros, the same but in scientific
# notation, and 1 if it's trailing zeros, -1 if it's
# decimal places.
mx = max( x )
rnd = mx
if ( round( mx ) > 1 ) {
inc = 0;
while ( rnd > 1 ) {
inc = inc + 1;
rnd = round( mx/( spacing^inc ) )
}
v = round( mx/spacing^(inc-1) )
f = spacing^(inc-1)
out = c( v,f,inc-1,1)
}
if ( round( mx ) == 1 ) {
out = c( 1, 1, 1, 0 )
}
if ( round( mx ) == 0 ) {
inc = 0;
while ( rnd < 1 ) {
inc = inc + 1;
rnd = round( mx*( spacing^inc ) )
}
v = round( mx*spacing^(inc) )
f = spacing^(inc)
out = c( v,f,inc,-1)
}
return( out )
}
plotConvergence( conv, F )
setwd("F:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('F:/CAM_postdoc/2018/NBack_03_19_2018/R/SDT_mixed_effects_model_check.R', echo=TRUE)
setwd("F:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('F:/CAM_postdoc/2018/NBack_03_19_2018/R/SDT_mixed_effects_model_check.R', echo=TRUE)
setwd("F:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('F:/CAM_postdoc/2018/NBack_03_19_2018/R/Conversion_from_csv_to_RData.R', echo=TRUE)
setwd("F:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('F:/CAM_postdoc/2018/NBack_03_19_2018/R/Conversion_from_csv_to_RData.R', echo=TRUE)
head( dat )
# Extract the variables of interest
dat = dat %>%
select( Subject,
ID,
Condition,
Timepoints,
Task,
Response_type,
Counts,
Trials,
Median_RT,
Self_report_on_high
)
?select
setwd("F:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('F:/CAM_postdoc/2018/NBack_03_19_2018/R/Conversion_from_csv_to_RData.R', echo=TRUE)
setwd("F:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('F:/CAM_postdoc/2018/NBack_03_19_2018/R/SDT_mixed_effects_model_check.R', echo=TRUE)
estimate_sdt = function( df,
X,
random,
var_names = c( 'Counts',
'Trials',
'Target',
'Subject' ),
n_iter = 2500,
chains = 4,
warmup = 500,
adapt_delta = .975,
... ) {
# Purpose:
# ...
# Arguments:
# df          -
# X           -
# random      -
# var_names   -
# n_iter      -
# chains      -
# warmup      -
# adapt_delta -
# Returns:
# ...
# Initialize variable for run time duration
run_time = Sys.time()
# Checks for correct input
# Forthcoming
# Input for stan script
stan_dat = list(
# Number of observations
No = nrow( df ),
# Number of subjects
Ns = max( df[ ,var_names[4] ] ),
# Number of group-level d' parameters
Nd = ncol( X[[1]] ),
# Number of group-level criterion parameters
Nc = ncol( X[[2]] ),
# Number of subject-level parameters
Nsp = length( random ),
# Observed counts
Y = df[ ,var_names[1] ],
# Total number of trials per observation
Nt = df[ ,var_names[2] ],
# Presence of target (1 = yes)
Co = df[ ,var_names[3] ],
# Subject index
subjIndex = df[ ,var_names[4] ],
# Design matrix for d'
Xd = X[[1]],
# Design matrix for criterion
Xc = X[[2]],
# Index for coefficients with random effects
eta_pos = random,
# Matrix with parameters governing priors
Priors = Priors
)
# Run stan script
fit = sampling( sdt_mix,
data = stan_dat,
warmup = warm,
iter = warm+niter,
chains = chains,
control = list( adapt_delta = adapt_delta ),
... )
# Extract convergence diagnostics
conv = convergenceExtract( fit, 'Tau' )
# Extract posterior samples
post = extract( fit )
# Compute run time duration
run_time = Sys.time() - run_time
# Return output
out = list(
post = post,
convergence = conv )
return( out )
}
res = estimate_sdt( dat, list( Xd, Xc ),
c( 1, 4 ) )
sim = data.frame(
Subject = subjIndex,
Target = Co,
Response_type = 'Hits',
Condition =
rep( rep( c( 'Control', 'Placebo', 'Drug' ), each = 2 ),
Ns ),
Counts = Y,
Trials = Nt,
stringsAsFactors = FALSE )
sim$Response_type[ sim$Target == 0 ] = 'False_alarms'
sim %>%
group_by( Response_type, Condition ) %>%
summarize( P = mean( Counts / Trials ) )
estimate_sdt = function( df,
X,
random,
Priors,
var_names = c( 'Counts',
'Trials',
'Target',
'Subject' ),
n_iter = 2500,
chains = 4,
warmup = 500,
adapt_delta = .975,
... ) {
# Purpose:
# ...
# Arguments:
# df          -
# X           -
# random      -
# var_names   -
# n_iter      -
# chains      -
# warmup      -
# adapt_delta -
# Returns:
# ...
# Initialize variable for run time duration
run_time = Sys.time()
# Checks for correct input
# Forthcoming
# Input for stan script
stan_dat = list(
# Number of observations
No = nrow( df ),
# Number of subjects
Ns = max( df[ ,var_names[4] ] ),
# Number of group-level d' parameters
Nd = ncol( X[[1]] ),
# Number of group-level criterion parameters
Nc = ncol( X[[2]] ),
# Number of subject-level parameters
Nsp = length( random ),
# Observed counts
Y = df[ ,var_names[1] ],
# Total number of trials per observation
Nt = df[ ,var_names[2] ],
# Presence of target (1 = yes)
Co = df[ ,var_names[3] ],
# Subject index
subjIndex = df[ ,var_names[4] ],
# Design matrix for d'
Xd = X[[1]],
# Design matrix for criterion
Xc = X[[2]],
# Index for coefficients with random effects
eta_pos = random,
# Matrix with parameters governing priors
Priors = Priors
)
# Run stan script
fit = sampling( sdt_mix,
data = stan_dat,
warmup = warm,
iter = warm+niter,
chains = chains,
control = list( adapt_delta = adapt_delta ),
... )
# Extract convergence diagnostics
conv = convergenceExtract( fit, 'Tau' )
# Extract posterior samples
post = extract( fit )
# Compute run time duration
run_time = Sys.time() - run_time
# Return output
out = list(
post = post,
convergence = conv )
return( out )
}
res = estimate_sdt( sim, list( Xd, Xc ),
c( 1, 4 ), Priors )
estimate_sdt = function( df,
X,
random,
Priors,
var_names = c( 'Counts',
'Trials',
'Target',
'Subject' ),
n_iter = 2500,
chains = 4,
warm = 500,
adapt_delta = .975,
... ) {
# Purpose:
# ...
# Arguments:
# df          -
# X           -
# random      -
# var_names   -
# n_iter      -
# chains      -
# warmup      -
# adapt_delta -
# Returns:
# ...
# Initialize variable for run time duration
run_time = Sys.time()
# Checks for correct input
# Forthcoming
# Input for stan script
stan_dat = list(
# Number of observations
No = nrow( df ),
# Number of subjects
Ns = max( df[ ,var_names[4] ] ),
# Number of group-level d' parameters
Nd = ncol( X[[1]] ),
# Number of group-level criterion parameters
Nc = ncol( X[[2]] ),
# Number of subject-level parameters
Nsp = length( random ),
# Observed counts
Y = df[ ,var_names[1] ],
# Total number of trials per observation
Nt = df[ ,var_names[2] ],
# Presence of target (1 = yes)
Co = df[ ,var_names[3] ],
# Subject index
subjIndex = df[ ,var_names[4] ],
# Design matrix for d'
Xd = X[[1]],
# Design matrix for criterion
Xc = X[[2]],
# Index for coefficients with random effects
eta_pos = random,
# Matrix with parameters governing priors
Priors = Priors
)
# Run stan script
fit = sampling( sdt_mix,
data = stan_dat,
warmup = warm,
iter = warm+niter,
chains = chains,
control = list( adapt_delta = adapt_delta ),
... )
# Extract convergence diagnostics
conv = convergenceExtract( fit, 'Tau' )
# Extract posterior samples
post = extract( fit )
# Compute run time duration
run_time = Sys.time() - run_time
# Return output
out = list(
post = post,
convergence = conv )
return( out )
}
res = estimate_sdt( sim, list( Xd, Xc ),
c( 1, 4 ), Priors )
estimate_sdt = function( df,
X,
random,
Priors,
var_names = c( 'Counts',
'Trials',
'Target',
'Subject' ),
niter = 2500,
chains = 4,
warm = 500,
adapt_delta = .975,
... ) {
# Purpose:
# ...
# Arguments:
# df          -
# X           -
# random      -
# var_names   -
# n_iter      -
# chains      -
# warmup      -
# adapt_delta -
# Returns:
# ...
# Initialize variable for run time duration
run_time = Sys.time()
# Checks for correct input
# Forthcoming
# Input for stan script
stan_dat = list(
# Number of observations
No = nrow( df ),
# Number of subjects
Ns = max( df[ ,var_names[4] ] ),
# Number of group-level d' parameters
Nd = ncol( X[[1]] ),
# Number of group-level criterion parameters
Nc = ncol( X[[2]] ),
# Number of subject-level parameters
Nsp = length( random ),
# Observed counts
Y = df[ ,var_names[1] ],
# Total number of trials per observation
Nt = df[ ,var_names[2] ],
# Presence of target (1 = yes)
Co = df[ ,var_names[3] ],
# Subject index
subjIndex = df[ ,var_names[4] ],
# Design matrix for d'
Xd = X[[1]],
# Design matrix for criterion
Xc = X[[2]],
# Index for coefficients with random effects
eta_pos = random,
# Matrix with parameters governing priors
Priors = Priors
)
# Run stan script
fit = sampling( sdt_mix,
data = stan_dat,
warmup = warm,
iter = warm + niter,
chains = chains,
control = list( adapt_delta = adapt_delta ),
... )
# Extract convergence diagnostics
conv = convergenceExtract( fit, 'Tau' )
# Extract posterior samples
post = extract( fit )
# Compute run time duration
run_time = Sys.time() - run_time
# Return output
out = list(
post = post,
convergence = conv )
return( out )
}
res = estimate_sdt( sim, list( Xd, Xc ),
c( 1, 4 ), Priors )
?extract
estimate_sdt = function( df,
X,
random,
Priors,
var_names = c( 'Counts',
'Trials',
'Target',
'Subject' ),
niter = 2500,
chains = 4,
warm = 500,
adapt_delta = .975,
... ) {
# Purpose:
# ...
# Arguments:
# df          -
# X           -
# random      -
# var_names   -
# n_iter      -
# chains      -
# warmup      -
# adapt_delta -
# Returns:
# ...
# Initialize variable for run time duration
run_time = Sys.time()
# Checks for correct input
# Forthcoming
# Input for stan script
stan_dat = list(
# Number of observations
No = nrow( df ),
# Number of subjects
Ns = max( df[ ,var_names[4] ] ),
# Number of group-level d' parameters
Nd = ncol( X[[1]] ),
# Number of group-level criterion parameters
Nc = ncol( X[[2]] ),
# Number of subject-level parameters
Nsp = length( random ),
# Observed counts
Y = df[ ,var_names[1] ],
# Total number of trials per observation
Nt = df[ ,var_names[2] ],
# Presence of target (1 = yes)
Co = df[ ,var_names[3] ],
# Subject index
subjIndex = df[ ,var_names[4] ],
# Design matrix for d'
Xd = X[[1]],
# Design matrix for criterion
Xc = X[[2]],
# Index for coefficients with random effects
eta_pos = random,
# Matrix with parameters governing priors
Priors = Priors
)
# Run stan script
fit = sampling( sdt_mix,
data = stan_dat,
warmup = warm,
iter = warm + niter,
chains = chains,
control = list( adapt_delta = adapt_delta ),
... )
# Extract convergence diagnostics
conv = convergenceExtract( fit, 'Tau' )
# Extract posterior samples
post = rstan::extract( fit )
# Compute run time duration
run_time = Sys.time() - run_time
# Return output
out = list(
post = post,
convergence = conv,
runtime = run_time )
return( out )
}
setwd("F:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('F:/CAM_postdoc/2018/NBack_03_19_2018/R/SDT_mixed_effects_model_check.R', echo=TRUE)
setwd("D:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/Figures_of_descriptive_stats.R')
devtools::install_github("rettopnivek/utilityf")
setwd("D:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/Figures_of_descriptive_stats.R')
setwd("D:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/Figures_of_descriptive_stats.R')
setwd("D:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/SDT_estimates_real_data.R')
# Exclude combined data
dtbf = dat %>%
filter( Task != 'Combined' )
?formula
scale( 1:3 )
1 + 1 + 2 + 6
Xd = matrix( 0, nrow( dtbf ), 1 + 1 + 2 + 6 )
head( dat )
setwd("D:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/Figures_of_descriptive_stats.R')
setwd("D:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/Figures_of_descriptive_stats.R')
run_code
tbl_cnt
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/Figures_of_descriptive_stats.R')
setwd("D:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/SDT_model_results.R')
plotConvergence( mdl$conv, savePlot )
ls()
str( pred )
pred[,1,2]
1 - pred[,1,2]
ls()
setwd("D:/CAM_postdoc/2018/NBack_03_19_2018/R")
source('D:/CAM_postdoc/2018/NBack_03_19_2018/R/Posterior_predictive_simulations.R')
