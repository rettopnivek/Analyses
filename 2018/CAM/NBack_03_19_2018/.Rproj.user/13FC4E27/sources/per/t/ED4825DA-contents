# Script to display model estimation results
# Written by Kevin Potter
# email: kevin.w.potter@gmail.com
# Please email me directory if you 
# have any questions or comments
# Last updated 2018-03-28

# Table of contents
# 1) Initial setup
# 2) Extract model estimation results
# 3) Convergence check
# 4) Posterior predictive checks for mean hits
# 5) ...
#   5.1) ...
#   5.2) ...

###
### 1) Initial setup
###

# Select model results to extract
model = 'm1'

# Save current working directory
orig_dir = getwd()

# Navigate to project directory
setwd( '..' )
proj_dir = getwd()

# Indicate whether to save figures in a PDF file
savePlot = F
if ( savePlot ) {
  setwd( 'Figures' )
  # pdf
  setwd( proj_dir )
}

# Indicate which code segments to run
run_code = c(
  F, # 
  F,
  F,
  F
)

# Load in useful packages

# Collection of useful functions
# devtools::install_github("rettopnivek/utilityf")
library( utilityf )

# Package for easier manipulation of data frames
# install.packages( 'dplyr' )
library( dplyr )

# Package for Bayesian estimation
# install.packages( 'rstan' )
library( rstan )
# For parallel processing
options(mc.cores = parallel::detectCores())
# Avoid recompilation
rstan_options(auto_write = TRUE)

# Load in data
setwd( 'Data' )
load( "NBack_3_19_2018.RData" )
setwd( proj_dir )

# Load in useful functions
setwd( 'R' )
source( 'Useful_functions.R' )
setwd( proj_dir )

# Load in estimation functions 
# and compile SDT model script
setwd( 'R' )
source( 'Estimation_functions.R' )

# Exclude combined data
dtbf = dat %>% 
  filter( Task != 'Combined' )

# Drop rows with missing 
# self-report data for subject 
# FN_041 (66)
# Subject FN_041 did not have any 
# self report data on how high
# for the T1 drug condition
dtbf = dtbf %>% 
  filter( Self_report_on_high != '-' )

# Create a new data frame that
# a) Excludes the combined trials
# b) Has separate variables for hits and false alarms
all_ptbp = dtbf %>% 
  filter( Task != 'Combined' & Response_type == 'Hits' ) %>% 
  arrange( Task, Condition, Timepoints, Subject ) %>% 
  mutate( H = Counts / Trials,
          fH = Counts, 
          Npos = Trials )
tmp = dtbf %>% 
  filter( Task != 'Combined' & Response_type == 'False_alarms' ) %>% 
  arrange( Task, Condition, Timepoints, Subject ) %>% 
  mutate( FA = Counts / Trials,
          fFA = Counts,
          Nneg = Trials )
all_ptbp$FA = tmp$FA
all_ptbp$fFA = tmp$fFA
all_ptbp$Nneg = tmp$Nneg

# Clean up workspace
rm( tmp )

# Convert the hit/false alarm rates into 
# estimates of d' and bias
all_ptbp = all_ptbp %>% 
  mutate( dp = sdt_calc_binary( fH, Npos, fFA, Nneg, 1, T ),
          crt = sdt_calc_binary( fH, Npos, fFA, Nneg, 1, F ) )

###
### 2) Extract model estimation results
###

# Navigate to folder with posterior estimates
# and posterior predictive checks
setwd( 'Data/Posterior_estimates' )

# Load in posterior estimates
fname = paste( 'Posterior_', model, '.RData', sep = '' )
load( fname )

# Standardize variable names
if ( model == 'm1' ) {
  mdl = m1
  X = X1
}

if ( model == 'm2' ) {
  mdl = m2
  X = X2
}

if ( model == 'm3' ) {
  mdl = m3
  X = X3
}

# Load in posterior predictive checks
fname = paste( 'PPC_', model, '.RData', sep = '' )
load( fname )

setwd( proj_dir )

###
### 3) Convergence check
###

if ( run_code[1] )
  plotConvergence( mdl$conv, savePlot )

###
### 4) Posterior predictive checks for mean hits
###

if ( run_code[2] ) {
  
  # Statistics for boxplots
  ct = all_ptbp %>% 
    group_by( Task, Condition, Timepoints ) %>% 
    summarize( mean_H = mean( H ),
               median_H = median( H ),
               LUI = quantile( simpleBootstrap( H )[[1]], .025 ),
               UUI = quantile( simpleBootstrap( H )[[1]], .975 ),
               LIQR = quantile( H, .25 ),
               UIQR = quantile( H, .75 ),
               Min = min( H ),
               Max = max( H )
    )
  
  # Indicate whether new plotting window should 
  # be generated or if figure should be saved as PDF
  if (!savePlot) x11(width = 12 )
  
  # Plotting characteristics
  lnSz = 2
  lnSz2 = 3
  txtSz = 1.5
  ptSz = 1.25
  axPos = -1.75
  pts = rep( c(22,24,25), 4 )
  clr = rep( rep( c( 'black', 'white' ), each = 3 ), 2 )
  
  # Create a blank plot
  xl = c( .5, 12.5 ); yl = c( .7, 1 )
  blankPlot( xl, yl )
  
  # Add grid lines
  horizLines( seq( .7, 1, .05 ), xl, col = 'grey80', 
              lwd = lnSz )
  customAxes( xl, yl )
  vertLines( 6.5, yl, lwd = lnSz )
  
  # Add axis labels
  axis( 1, c( 3.5, 9.5 ), 
        c( '0-back', '2-back' ),
        tick = F, line = axPos, cex.axis = txtSz )
  mtext( 'Task', side = 1, line = 1.5, cex = txtSz )
  axis( 2, seq( .7, 1, .1 ),
        seq( .7, 1, .1 ) * 100, 
        tick = F, line = axPos, cex.axis = txtSz )
  mtext( 'Percent hits', side = 2, line = 1.5, cex = txtSz )
  
  # 95% credible interval for posterior checks
  segments( 1:12, pred[,'CI_2.5','H'],
            1:12, pred[,'CI_97.5','H'], 
            lwd = lnSz2, col = 'grey' )
  # 68% credible interval for posterior checks
  errorBars( 1:12, rbind(
    pred[,'CI_16','H'],
    pred[,'CI_84','H'] ), 
    lwd = lnSz2, col = 'grey', length = .05 )
  # Mean for posterior checks
  points( 1:12, pred[,'Mean','H'], pch = 19, 
          col = 'grey', cex = ptSz )
  
  # Lines for timepoints
  for ( i in 1:4 ) {
    xa = 1:3 + 3*(i-1)
    lines( xa, ct$mean_H[xa],
           lwd = lnSz )
  }
  
  # Mean
  points( 1:12, ct$mean_H, pch = pts, 
          bg = clr, cex = ptSz )
  
  # Add legends
  sel = c( 1,4)
  legend( 4.85, 1.05, ct$Condition[sel],
          pch = 22, pt.bg = clr[sel],
          bty = 'n', cex = txtSz, xpd = T,
          horiz = T )
  
  lbs = rep( 'Pre-drug', 12 )
  lbs[ ct$Timepoints == 'T2_Post_drug' ] = 'Peak drug'
  lbs[ ct$Timepoints == 'T3_Post_drug' ] = 'Recovery'
  
  sel = c( 1:3 )
  legend( 0, .65, lbs[sel],
          pch = pts[sel], pt.bg = 'black',
          bty = 'n', cex = txtSz, xpd = T,
          horiz = T )
  
  legend( 7.5, .65, c( 'Observed', 'Predicted' ),
          fill = c('black','grey'), 
          bty = 'n', cex = txtSz, xpd = T,
          horiz = T )
  
}

###
### 5)
###

# 5.1)
get_scatter_data = function( Cond ) {
  # Purpose:
  # A convenience function to extract the 
  # relevant data to create scatter plots 
  # over a desired set of conditions.
  # Arguments:
  # Cond - A list with the desired task, 
  #        condition, and post-drug 
  #        time point to include.
  # Returns:
  # A data frame with the measurements for the 
  # initial time point and the subsequent time 
  # point for the desired task and condition.
  
  pre = 'T1_Pre_drug'
  po = Cond[[3]]
  
  # Extract data to be plotted
  dtbp = all_ptbp %>% 
    filter( Task == Cond[[1]] & 
              Condition == Cond[[2]] & 
              ( Timepoints == pre | 
                  Timepoints == po )
    )
  
  # Find subjects with complete pre-post pairs
  sel0 = dtbp$Timepoints == pre
  sel1 = dtbp$Timepoints == po
  s0 = dtbp$Subject[ sel0 ]
  s1 = dtbp$Subject[ sel1 ]
  
  if ( length( s0 ) > length( s1 ) ) {
    subjects = s0[ s0 %in% s1 ]
  } else {
    subjects = s1[ s1 %in% s0 ]
  }
  
  # Trim out incomplete pairs
  sel = dtbp$Subject %in% subjects
  dtbp = dtbp[ sel, ]
  
  # Sort data by subjects
  dtbp = dtbp %>% 
    arrange( Subject, Timepoints )
  
  # Add convenience variable for pre-post separation
  dtbp$Pre = FALSE
  dtbp$Pre[ dtbp$Timepoints == pre ] = TRUE
  
  # Return data frame with plotting data
  return( dtbp )
}

# 5.2)
quick_scatter_pred = function( cond, 
                               value,
                               yl,
                               yax,
                               y_lbl,
                               l_adj ) {
  # Purpose:
  # Generates a scatter plot of observed estimates 
  # versus self-reported highs, with model 
  # predictions overlaid.
  # Arguments:
  # cond  - A list with the desired task, 
  #         condition, and post-drug 
  #         time point to include
  # value - The variable to plot (e.g., 'dp')
  # yl    - The lower and upper boundaries for 
  #         the y-axis
  # yax   - The lower and upper values of the range, 
  #         along with the increment, for the 
  #         gridlines for the y-axis
  # y_lbl - The y-axis label
  # l_adj - The adjustment for the upper boundary 
  #         of the y-axis at which to report 
  #         the correlation and p-value
  
  # Extract relevant data
  dtbp = get_scatter_data( cond )
  
  # Create a blank plot
  xl = c(-5,105)
  blankPlot( xl, yl )
  
  # Add axis labels
  axis( 1, seq( 0, 100, 20 ),
        tick = F, line = -1.75, cex.axis = txtSz )
  mtext( 'Self-reported high', side = 1, line = 1,
         cex = txtSz )
  
  axis( 2, seq( yax[1], yax[2], yax[3] ),
        tick = F, line = -1.75, cex.axis = txtSz*.9 )
  mtext( y_lbl, side = 2, line = 1.5,
         cex = txtSz )
  
  # Extract x and y values
  y = dtbp[ dtbp$Pre == F, value ] - 
    dtbp[ dtbp$Pre == T, value ]
  x = as.numeric( dtbp$Self_report_on_high[ dtbp$Pre == F ] )
  
  # Prediction interval
  sel = pred_2_cnd[,1] == cond[[1]] & 
    pred_2_cnd[,2] == cond[[2]] & 
    pred_2_cnd[,3] == cond[[3]]
  pi = rbind(
    pred_2[sel,,'Mean',value],
    pred_2[sel,,'PI_2.5',value],
    pred_2[sel,,'PI_97.5',value] )
  
  xi = c( seq(0,100,10), rev( seq( 0, 100, 10 ) ) )
  yi = c( pi[2,], rev( pi[3,] ) )
  yi[ yi > yl[2] ] = yl[2]
  yi[ yi < yl[1] ] = yl[1]
  polygon( xi, yi, 
           col = 'grey90', border = NA )
  lines( xi[1:11], pi[1,], lwd = lnSz, lty = 2 )
  
  horizLines( seq( yax[1], yax[2], yax[3] ), xl, 
              col = 'grey80', lwd = lnSz )
  customAxes( xl, yl )
  
  # Add observations
  points( x, y, pch = 21, bg = 'black', cex = ptSz )
  
}

if ( run_code[3] ) {
  
  # Plotting characteristics
  lnSz = 2
  txtSz = 1.5
  ptSz = 1.25
  
  for ( i in 1:nrow( pred_2_cnd ) ) {
    
    if ( i %% 2 == 1 ) {
      # Indicate whether new plotting window should 
      # be generated or if figure should be saved as PDF
      if (!savePlot) x11(width = 12 )
      # Create two plotting planes
      layout( cbind( 1, 2 ) )
    }
    
    # Create input for custom scatter plot function
    cond = list( pred_2_cnd[i,1],
                 pred_2_cnd[i,2],
                 pred_2_cnd[i,3] )
    
    # Create scatter plot
    quick_scatter_pred( cond, 'dp',
                   c(-4.5,4.5),
                   c(-4,4,1),
                   "Differences in d'",
                   1.1 )
    
    # Add a title for the drug condition
    # (Placebo vs. drug)
    title( pred_2_cnd[i,2], cex = txtSz )
    
    # Add additional details regarding the 
    # task and timepoints
    if ( i %% 2 == 1 ) {
      if ( pred_2_cnd[i,1] == 'NBack_0' ) {
        tsk = '0-back'
      } else {
        tsk = '2-back'
      }
      
      if ( pred_2_cnd[i,3] == 'T2_Post_drug' ) {
        tm = '(Peak drug - pre-drug )'
      } else {
        tm = '(Post drug - pre-drug )'
      }
      
      mtext( paste( tsk, tm ), 
             side = 1, adj = 0, cex = txtSz,
             line = 2.5 ); 
    }
    
  }
  
}

###
###
###

if ( run_code[4] ) {
  
  # Define function to compute metrics of choice 
  # over posterior samples
  quick_ci = function(x) {
    
    p = c( .025, .16, .5, .84, .975 )
    q = quantile( x, p )
    names( q ) = c(
      'CI_2.5',
      'CI_16',
      'Median',
      'CI_84',
      'CI_97.5' )
    out = c(
      Mean = mean( x ),
      q )
    return( out )
  }
  
  # Define function to quickly plot credible intervals 
  # for posterior samples
  plt_ci = function( pos, ci, clr = 'black' ) {
    
    segments( pos, ci['CI_2.5'],
              pos, ci['CI_97.5'],
              lwd = lnSz, col = clr )
    errorBars( pos, ci[c('CI_16','CI_84')],
               lwd = lnSz, length = .05, col = clr )
    points( pos, ci['Mean'], pch = 19, cex = ptSz, col = clr )
    points( pos, ci['Median'], pch = '-', cex = ptSz, col = clr )
    
  }
  
  # Details regarding posterior samples
  dps = 1:ncol( X[[1]] )
  cs = 1:ncol( X[[2]] ) + ncol( X[[1]] )
  
  # Parameter labels
  dp_n = colnames( X[[1]] )
  c_n = colnames( X[[2]] )
  
  ### d' ###
  
  ptbp = mdl$post$group_param[,dps]
  colnames( ptbp ) = dp_n
  ptbp = ptbp[, -(grep('Baseline', dp_n))]
  cip = apply( ptbp, 2, quick_ci )
  
  # Indicate whether new plotting window should 
  # be generated or if figure should be saved as PDF
  if (!savePlot) x11(width = 12 )
  par( mar = c( 7, 3, .5, .5 ) )
  
  # Plotting characteristics
  lnSz = 2
  txtSz = 1.5
  ptSz = 1.25
  axPos = -1.75
  
  yl = lowerUpper( .5, as.vector( cip ) )
  xl = c( .5, .5 + ncol(cip) )
  blankPlot( xl, yl )
  horizLines( seq( yl[1], yl[2], .5 ), 
              xl, lwd = lnSz, col = 'grey80' )
  horizLines( 0, xl, lwd = lnSz )
  customAxes( xl, yl, lnSz = lnSz )
  
  axis( 2, seq( yl[1], yl[2], .5 ), 
        tick = F, line = -1.75, cex.axis = txtSz )
  mtext( "d' posterior estimates", side = 2, 
         line = 1.5, cex = txtSz )
  
  if ( model == 'm3' ) {
    clr = rep( 'black', ncol( cip ) )
    clr[ c( grep( 'Drug', colnames(cip) ), 
         grep( 'Self', colnames( cip ) ) ) ] = 'blue'
  }
  for ( i in 1:ncol(cip) ) plt_ci( i, cip[,i], clr = clr[i] )
  
  xa = 1:ncol( cip )
  lbl = colnames( cip )
  axis( 1, at = xa, tick = F, labels = FALSE )
  text( x = xa, 
        y = par()$usr[3]+0.0*(par()$usr[4]-par()$usr[3]),
       labels = lbl, srt = 45, adj = 1, xpd = TRUE )
  
  ### Criterion ###
  
  ptbp = mdl$post$group_param[,cs]
  colnames( ptbp ) = c_n
  cip = apply( ptbp, 2, quick_ci )
  
  # Indicate whether new plotting window should 
  # be generated or if figure should be saved as PDF
  if (!savePlot) x11(width = 12 )
  par( mar = c( 7, 3, .5, .5 ) )
  
  # Plotting characteristics
  lnSz = 2
  txtSz = 1.5
  ptSz = 1.25
  axPos = -1.75
  
  yl = lowerUpper( .5, as.vector( cip ) )
  xl = c( .5, .5 + ncol(cip) )
  blankPlot( xl, yl )
  horizLines( seq( yl[1], yl[2], .5 ), 
              xl, lwd = lnSz, col = 'grey80' )
  horizLines( 0, xl, lwd = lnSz )
  customAxes( xl, yl, lnSz = lnSz )
  
  axis( 2, seq( yl[1], yl[2], .5 ), 
        tick = F, line = -1.75, cex.axis = txtSz )
  mtext( "Criterion posterior estimates", side = 2, 
         line = 1.5, cex = txtSz )
  
  for ( i in 1:ncol(cip) ) plt_ci( i, cip[,i] )
  
  xa = 1:ncol( cip )
  lbl = colnames( cip )
  axis( 1, at = xa, tick = F, labels = FALSE )
  text( x = xa, 
        y = par()$usr[3]+0.0*(par()$usr[4]-par()$usr[3]),
        labels = lbl, srt = 45, adj = 1, xpd = TRUE )
  
}



setwd( orig_dir )